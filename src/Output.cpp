#include "config.h"
#include "Output.h"
#include "Hash.h"
#include <boost/date_time/posix_time/posix_time.hpp>

using namespace std;
using namespace boost;
using namespace boost::posix_time;

const uint32 outTaskRequirement[] = {
	H_CRC,
	H_MD5,
	H_ED2K
};

namespace __output {
	void writeHeader(string commentStart, Writer stream) {
		ptime now = second_clock::local_time();
		*stream << commentStart << " Generated by ArXSum " << VERSION << " on " << 
			to_iso_extended_string(now.date()) << " at " << 
			to_simple_string(now.time_of_day()) << endl;
    *stream << commentStart << " ArXSum includes cryptographic software written by Eric Young (eay@cryptsoft.com)" << endl;
    *stream << commentStart << " (c) Alexander 'Elric' Fokin, [ArX] Team, 2007" << endl;
	}

	void writeTimesAndSizes(string commentStart, ArrayList<FileEntry> data, Writer stream) {
		FOREACH(FileEntry file, data) {
			if(!file.isFailed()) {
				ptime fileTime = from_time_t(file.getDateTime());
				*stream << commentStart << " " << setw(12) << file.getSize() << "  " << 
					 to_simple_string(fileTime.time_of_day()) << " " << 
					 to_iso_extended_string(fileTime.date()) << " " << file.getPath() << endl;
			}
		}
	}

	class OutputFormatImpl {
	private:
	public:
		virtual void output(HashTask task, ArrayList<FileEntry> data, Writer stream) = 0;
		virtual string getName() = 0;
	};

	class MD5OutputFormat: public OutputFormatImpl {
	private:
	public:
		void output(HashTask task, ArrayList<FileEntry> data, Writer stream) {
			writeHeader(";", stream);
			*stream << ";" << endl;
			writeTimesAndSizes(";", data, stream);
			for(uint32 n = 0; n < H_COUNT; n++) {
				if(task.isSet(n) && n != H_MD5) {
					*stream << ";" << endl << "; * " << Hash::getName(n) << " Block *" << endl;
					FOREACH(FileEntry file, data)
						if(!file.isFailed())
							*stream << "; " << file.getDigest(n) << " *" << file.getPath() << endl;
				}
			}
			FOREACH(FileEntry file, data)
				if(!file.isFailed())
					*stream << file.getDigest(H_MD5) << " *" << file.getPath() << endl;
		}
		string getName() {
			return "MD5";
		}
	};

	class SFVOutputFormat: public OutputFormatImpl {
	private:
	public:
		void output(HashTask task, ArrayList<FileEntry> data, Writer stream) {
			writeHeader(";", stream);
			*stream << ";" << endl;
			writeTimesAndSizes(";", data, stream);
			FOREACH(FileEntry file, data)
				if(!file.isFailed())
					*stream << file.getPath() << " " << file.getDigest(H_CRC) << endl;
		}
		string getName() {
			return "SFV";
		}
	};

	class ED2KOutputFormat: public OutputFormatImpl {
	private:
	public:
		void output(HashTask task, ArrayList<FileEntry> data, Writer stream) {
			//ed2k://|file|Amaenaide yo!! Katsu!! - 01 =Mendoi=.avi|244576256|bd4bffffc7664e11e85485383c984507|/
			FOREACH(FileEntry file, data)
				if(!file.isFailed())
					*stream << "ed2k://|file|" << file.getPath().leaf() << "|" << 
						file.getSize() << "|" << file.getDigest(H_ED2K) << "|/" << endl;
		}
		string getName() {
			return "ED2K";
		}
	};
};

OutputFormat::OutputFormat(uint32 ofId) {
	switch(ofId) {
	case O_MD5:
		impl.reset(new __output::MD5OutputFormat());
		break;
	case O_SFV:
		impl.reset(new __output::SFVOutputFormat());
		break;
	case O_ED2K:
		impl.reset(new __output::ED2KOutputFormat());
		break;
	default:
		throw new std::runtime_error("Unknowh Output Format Id: " + lexical_cast<string>(ofId));
	}
}

void OutputFormat::output(HashTask task, ArrayList<FileEntry> data, Writer stream) {
	impl->output(task, data, stream);
}

string OutputFormat::getName() {
	return impl->getName();
}

std::string OutputFormat::getName(uint32 ofId) {
	return OutputFormat(ofId).getName();
}

uint32 OutputFormat::getId() {
	return this->ofId;
}



